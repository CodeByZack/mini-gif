{"version":3,"sources":["mini-gif.esm.js","App.js","index.js"],"names":["NeuQuant","alphadec","thepicture","lengthcount","samplefac","network","exports","netsize","prime1","prime2","prime3","prime4","minpicturebytes","maxnetpos","netbiasshift","ncycles","intbiasshift","intbias","gammashift","betashift","beta","betagamma","initrad","radiusbiasshift","radiusbias","initradius","radiusdec","alphabiasshift","initalpha","radbiasshift","radbias","alpharadbshift","alpharadbias","netindex","bias","freq","radpower","thepic","len","sample","i","p","Array","colorMap","map","index","k","l","j","inxbuild","smallpos","smallval","q","previouscol","startpos","learn","b","g","r","radius","rad","alpha","step","delta","samplepixels","pix","lim","contest","altersingle","alterneigh","unbiasnet","dist","a","bestd","best","process","lo","hi","m","e","n","biasdist","betafreq","bestpos","bestbiaspos","bestbiasd","apply","this","arguments","LZWEncoder","imgW","imgH","pixAry","initCodeSize","remaining","curPixel","n_bits","maxcode","g_init_bits","ClearCode","EOFCode","a_count","EOF","BITS","HSIZE","maxbits","maxmaxcode","htab","codetab","hsize","free_ent","clear_flg","cur_accum","cur_bits","masks","accum","width","height","pixels","color_depth","Math","max","char_out","c","outs","flush_char","cl_block","cl_hash","output","compress","init_bits","fcode","ent","disp","hsize_reg","hshift","MAXCODE","nextPixel","outer_loop","encode","os","writeByte","writeBytes","code","GifReaderLZWOutputIndexStream","code_stream","output_length","min_code_size","clear_code","eoi_code","next_code","cur_code_size","code_mask","cur_shift","cur","op","subblock_size","code_table","Int32Array","prev_code","chase_code","chase_length","chase","console","log","GIFEncoder","chr","String","fromCharCode","ByteArray","bin","prototype","getData","v","length","getUnit8Array","arr","Uint8Array","val","push","writeUTFBytes","string","charCodeAt","array","offset","transIndex","out","image","indexedPixels","colorDepth","colorTab","transparent","repeat","delay","started","usedEntry","palSize","dispose","firstFrame","sizeSet","comment","reset","setDelay","ms","round","setDispose","setRepeat","iter","setTransparent","setComment","addFrame","im","is_imageData","Error","ok","getImageData","canvas","data","setSize","getImagePixels","analyzePixels","writeLSD","writePalette","writeNetscapeExt","writeGraphicCtrlExt","writeCommentExt","writeImageDesc","writePixels","finish","setFrameRate","fps","setQuality","quality","w","h","start","cont","nPix","nq","findClosest","minpos","dmin","dr","dg","db","d","count","transp","WriteShort","pValue","stream","setProperties","has_start","is_first","GIFDecoder","buf","pf0","global_palette_flag","num_global_colors","global_palette_offset","global_palette_size","no_eof","frames","transparent_index","disposal","loop_count","block_size","pf1","toString","x","y","pf2","interlace_flag","num_local_colors","palette_offset","palette_size","has_local_palette","data_offset","data_length","interlaced","numFrames","loopCount","frameInfo","frame_num","decodeAndBlitFrameBGRA","frame","num_pixels","index_stream","trans","framewidth","framestride","xleft","opbeg","opend","scanstride","interlaceskip","il","decodeAndBlitFrameRGBA","useStyles","makeStyles","theme","mt10","marginTop","spacing","tipline","textAlign","tipLabel","color","palette","secondary","main","paddingRight","App","useState","file","setFile","playStatus","setPlayStatus","nowFrame","setNowFrame","jumpFrame","setJumpFrame","downloadUrl","setDownloadUrl","changedFrames","setChangedFrames","inputConfig","setInputConfig","gifInfo","setGifInfo","gifFrames","setGifFrames","decode","arrayBuffer","arrBuf","decodeGif","minigif","Uint8ClampedArray","imagedata","ImageData","set","useEffect","useGif","playCanvasRef","useRef","styles","handleInput","key","value","target","handleClick","type","handleEdit","alert","generateGif","text","startFrame","endFrame","ctx","current","getContext","font","resArr","putImageData","fillStyle","fillText","handleChangeStatus","startLoop","encoder","Blob","url","URL","createObjectURL","setTimeout","loop","next","drawFrame","className","AppBar","position","Toolbar","Typography","variant","Container","maxWidth","Paper","square","ref","Slider","valueLabelDisplay","getAriaValueText","onChange","num","aria-labelledby","component","Grid","container","item","xs","Button","disableElevation","TextField","style","opacity","label","placeholder","files","InputLabelProps","shrink","ButtonGroup","aria-label","onClick","src","download","href","ReactDOM","render","StrictMode","Fragment","CssBaseline","document","getElementById"],"mappings":"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","file":"static/js/main.8a28a294.chunk.js","sourcesContent":["/* eslint-disable */\r\n/*\r\n * NeuQuant Neural-Net Quantization Algorithm\r\n * ------------------------------------------\r\n *\r\n * Copyright (c) 1994 Anthony Dekker\r\n *\r\n * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994. See\r\n * \"Kohonen neural networks for optimal colour quantization\" in \"Network:\r\n * Computation in Neural Systems\" Vol. 5 (1994) pp 351-367. for a discussion of\r\n * the algorithm.\r\n *\r\n * Any party obtaining a copy of these files from the author, directly or\r\n * indirectly, is granted, free of charge, a full and unrestricted irrevocable,\r\n * world-wide, paid up, royalty-free, nonexclusive right and license to deal in\r\n * this software and documentation files (the \"Software\"), including without\r\n * limitation the rights to use, copy, modify, merge, publish, distribute,\r\n * sublicense, and/or sell copies of the Software, and to permit persons who\r\n * receive copies from any such party to do so, with the only requirement being\r\n * that this copyright notice remain intact.\r\n */\r\n\r\n/*\r\n * This class handles Neural-Net quantization algorithm\r\n * @author Kevin Weiner (original Java version - kweiner@fmsware.com)\r\n * @author Thibault Imbert (AS3 version - bytearray.org)\r\n * @author Kevin Kwok (JavaScript version - https://github.com/antimatter15/jsgif)\r\n * @version 0.1 AS3 implementation\r\n */\r\n\r\nvar NeuQuant = function() {\r\n\r\n  var exports = {};\r\n  var netsize = 256; /* number of colours used */\r\n\r\n  /* four primes near 500 - assume no image has a length so large */\r\n  /* that it is divisible by all four primes */\r\n\r\n  var prime1 = 499;\r\n  var prime2 = 491;\r\n  var prime3 = 487;\r\n  var prime4 = 503;\r\n  var minpicturebytes = (3 * prime4); /* minimum size for input image */\r\n\r\n  /*\r\n   * Program Skeleton ---------------- [select samplefac in range 1..30] [read\r\n   * image from input file] pic = (unsigned char*) malloc(3*width*height);\r\n   * initnet(pic,3*width*height,samplefac); learn(); unbiasnet(); [write output\r\n   * image header, using writecolourmap(f)] inxbuild(); write output image using\r\n   * inxsearch(b,g,r)\r\n   */\r\n\r\n  /*\r\n   * Network Definitions -------------------\r\n   */\r\n\r\n  var maxnetpos = (netsize - 1);\r\n  var netbiasshift = 4; /* bias for colour values */\r\n  var ncycles = 100; /* no. of learning cycles */\r\n\r\n  /* defs for freq and bias */\r\n  var intbiasshift = 16; /* bias for fractions */\r\n  var intbias = (1 << intbiasshift);\r\n  var gammashift = 10; /* gamma = 1024 */\r\n  var betashift = 10;\r\n  var beta = (intbias >> betashift); /* beta = 1/1024 */\r\n  var betagamma = (intbias << (gammashift - betashift));\r\n\r\n  /* defs for decreasing radius factor */\r\n  var initrad = (netsize >> 3); /* for 256 cols, radius starts */\r\n  var radiusbiasshift = 6; /* at 32.0 biased by 6 bits */\r\n  var radiusbias = (1 << radiusbiasshift);\r\n  var initradius = (initrad * radiusbias); /* and decreases by a */\r\n  var radiusdec = 30; /* factor of 1/30 each cycle */\r\n\r\n  /* defs for decreasing alpha factor */\r\n  var alphabiasshift = 10; /* alpha starts at 1.0 */\r\n  var initalpha = (1 << alphabiasshift);\r\n  var alphadec; /* biased by 10 bits */\r\n\r\n  /* radbias and alpharadbias used for radpower calculation */\r\n  var radbiasshift = 8;\r\n  var radbias = (1 << radbiasshift);\r\n  var alpharadbshift = (alphabiasshift + radbiasshift);\r\n  var alpharadbias = (1 << alpharadbshift);\r\n\r\n  /*\r\n   * Types and Global Variables --------------------------\r\n   */\r\n\r\n  var thepicture; /* the input image itself */\r\n  var lengthcount; /* lengthcount = H*W*3 */\r\n  var samplefac; /* sampling factor 1..30 */\r\n\r\n  // typedef int pixel[4]; /* BGRc */\r\n  var network; /* the network itself - [netsize][4] */\r\n  var netindex = [];\r\n\r\n  /* for network lookup - really 256 */\r\n  var bias = [];\r\n\r\n  /* bias and freq arrays for learning */\r\n  var freq = [];\r\n  var radpower = [];\r\n\r\n  var NeuQuant = exports.NeuQuant = function NeuQuant(thepic, len, sample) {\r\n\r\n    var i;\r\n    var p;\r\n\r\n    thepicture = thepic;\r\n    lengthcount = len;\r\n    samplefac = sample;\r\n\r\n    network = new Array(netsize);\r\n\r\n    for (i = 0; i < netsize; i++) {\r\n\r\n      network[i] = new Array(4);\r\n      p = network[i];\r\n      p[0] = p[1] = p[2] = (i << (netbiasshift + 8)) / netsize;\r\n      freq[i] = intbias / netsize; /* 1/netsize */\r\n      bias[i] = 0;\r\n    }\r\n  };\r\n\r\n  var colorMap = function colorMap() {\r\n\r\n    var map = [];\r\n    var index = new Array(netsize);\r\n\r\n    for (var i = 0; i < netsize; i++)\r\n      index[network[i][3]] = i;\r\n\r\n    var k = 0;\r\n    for (var l = 0; l < netsize; l++) {\r\n      var j = index[l];\r\n      map[k++] = (network[j][0]);\r\n      map[k++] = (network[j][1]);\r\n      map[k++] = (network[j][2]);\r\n    }\r\n\r\n    return map;\r\n  };\r\n\r\n  /*\r\n   * Insertion sort of network and building of netindex[0..255] (to do after\r\n   * unbias)\r\n   * -------------------------------------------------------------------------------\r\n   */\r\n\r\n  var inxbuild = function inxbuild() {\r\n\r\n    var i;\r\n    var j;\r\n    var smallpos;\r\n    var smallval;\r\n    var p;\r\n    var q;\r\n    var previouscol;\r\n    var startpos;\r\n\r\n    previouscol = 0;\r\n    startpos = 0;\r\n    for (i = 0; i < netsize; i++) {\r\n\r\n      p = network[i];\r\n      smallpos = i;\r\n      smallval = p[1]; /* index on g */\r\n\r\n      /* find smallest in i..netsize-1 */\r\n      for (j = i + 1; j < netsize; j++) {\r\n\r\n        q = network[j];\r\n        if (q[1] < smallval) { /* index on g */\r\n          smallpos = j;\r\n          smallval = q[1]; /* index on g */\r\n        }\r\n      }\r\n      q = network[smallpos];\r\n\r\n      /* swap p (i) and q (smallpos) entries */\r\n      if (i != smallpos) {\r\n        j = q[0];\r\n        q[0] = p[0];\r\n        p[0] = j;\r\n        j = q[1];\r\n        q[1] = p[1];\r\n        p[1] = j;\r\n        j = q[2];\r\n        q[2] = p[2];\r\n        p[2] = j;\r\n        j = q[3];\r\n        q[3] = p[3];\r\n        p[3] = j;\r\n      }\r\n\r\n      /* smallval entry is now in position i */\r\n\r\n      if (smallval != previouscol) {\r\n\r\n        netindex[previouscol] = (startpos + i) >> 1;\r\n\r\n        for (j = previouscol + 1; j < smallval; j++) netindex[j] = i;\r\n\r\n        previouscol = smallval;\r\n        startpos = i;\r\n      }\r\n    }\r\n\r\n    netindex[previouscol] = (startpos + maxnetpos) >> 1;\r\n    for (j = previouscol + 1; j < 256; j++) netindex[j] = maxnetpos; /* really 256 */\r\n  };\r\n\r\n  /*\r\n   * Main Learning Loop ------------------\r\n   */\r\n\r\n  var learn = function learn() {\r\n\r\n    var i;\r\n    var j;\r\n    var b;\r\n    var g;\r\n    var r;\r\n    var radius;\r\n    var rad;\r\n    var alpha;\r\n    var step;\r\n    var delta;\r\n    var samplepixels;\r\n    var p;\r\n    var pix;\r\n    var lim;\r\n\r\n    if (lengthcount < minpicturebytes) samplefac = 1;\r\n\r\n    alphadec = 30 + ((samplefac - 1) / 3);\r\n    p = thepicture;\r\n    pix = 0;\r\n    lim = lengthcount;\r\n    samplepixels = lengthcount / (3 * samplefac);\r\n    delta = (samplepixels / ncycles) | 0;\r\n    alpha = initalpha;\r\n    radius = initradius;\r\n\r\n    rad = radius >> radiusbiasshift;\r\n    if (rad <= 1) rad = 0;\r\n\r\n    for (i = 0; i < rad; i++) radpower[i] = alpha * (((rad * rad - i * i) * radbias) / (rad * rad));\r\n\r\n    if (lengthcount < minpicturebytes) step = 3;\r\n\r\n    else if ((lengthcount % prime1) !== 0) step = 3 * prime1;\r\n\r\n    else {\r\n\r\n      if ((lengthcount % prime2) !== 0) step = 3 * prime2;\r\n      else {\r\n        if ((lengthcount % prime3) !== 0) step = 3 * prime3;\r\n        else step = 3 * prime4;\r\n      }\r\n    }\r\n\r\n    i = 0;\r\n    while (i < samplepixels) {\r\n\r\n      b = (p[pix + 0] & 0xff) << netbiasshift;\r\n      g = (p[pix + 1] & 0xff) << netbiasshift;\r\n      r = (p[pix + 2] & 0xff) << netbiasshift;\r\n      j = contest(b, g, r);\r\n\r\n      altersingle(alpha, j, b, g, r);\r\n      if (rad !== 0) alterneigh(rad, j, b, g, r); /* alter neighbours */\r\n\r\n      pix += step;\r\n      if (pix >= lim) pix -= lengthcount;\r\n\r\n      i++;\r\n\r\n      if (delta === 0) delta = 1;\r\n\r\n      if (i % delta === 0) {\r\n        alpha -= alpha / alphadec;\r\n        radius -= radius / radiusdec;\r\n        rad = radius >> radiusbiasshift;\r\n\r\n        if (rad <= 1) rad = 0;\r\n\r\n        for (j = 0; j < rad; j++) radpower[j] = alpha * (((rad * rad - j * j) * radbias) / (rad * rad));\r\n      }\r\n    }\r\n  };\r\n\r\n  /*\r\n   ** Search for BGR values 0..255 (after net is unbiased) and return colour\r\n   * index\r\n   * ----------------------------------------------------------------------------\r\n   */\r\n\r\n  var map = exports.map = function map(b, g, r) {\r\n\r\n    var i;\r\n    var j;\r\n    var dist;\r\n    var a;\r\n    var bestd;\r\n    var p;\r\n    var best;\r\n\r\n    bestd = 1000; /* biggest possible dist is 256*3 */\r\n    best = -1;\r\n    i = netindex[g]; /* index on g */\r\n    j = i - 1; /* start at netindex[g] and work outwards */\r\n\r\n    while ((i < netsize) || (j >= 0)) {\r\n\r\n      if (i < netsize) {\r\n        p = network[i];\r\n        dist = p[1] - g; /* inx key */\r\n\r\n        if (dist >= bestd) i = netsize; /* stop iter */\r\n\r\n        else {\r\n\r\n          i++;\r\n          if (dist < 0) dist = -dist;\r\n          a = p[0] - b;\r\n          if (a < 0) a = -a;\r\n          dist += a;\r\n\r\n          if (dist < bestd) {\r\n            a = p[2] - r;\r\n            if (a < 0) a = -a;\r\n            dist += a;\r\n\r\n            if (dist < bestd) {\r\n              bestd = dist;\r\n              best = p[3];\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      if (j >= 0) {\r\n\r\n        p = network[j];\r\n        dist = g - p[1]; /* inx key - reverse dif */\r\n\r\n        if (dist >= bestd) j = -1; /* stop iter */\r\n\r\n        else {\r\n\r\n          j--;\r\n          if (dist < 0) dist = -dist;\r\n          a = p[0] - b;\r\n          if (a < 0) a = -a;\r\n          dist += a;\r\n\r\n          if (dist < bestd) {\r\n            a = p[2] - r;\r\n            if (a < 0) a = -a;\r\n            dist += a;\r\n            if (dist < bestd) {\r\n              bestd = dist;\r\n              best = p[3];\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return (best);\r\n  };\r\n\r\n  var process = exports.process = function process() {\r\n    learn();\r\n    unbiasnet();\r\n    inxbuild();\r\n    return colorMap();\r\n  };\r\n\r\n  /*\r\n   * Unbias network to give byte values 0..255 and record position i to prepare\r\n   * for sort\r\n   * -----------------------------------------------------------------------------------\r\n   */\r\n\r\n  var unbiasnet = function unbiasnet() {\r\n\r\n    var i;\r\n\r\n    for (i = 0; i < netsize; i++) {\r\n      network[i][0] >>= netbiasshift;\r\n      network[i][1] >>= netbiasshift;\r\n      network[i][2] >>= netbiasshift;\r\n      network[i][3] = i; /* record colour no */\r\n    }\r\n  };\r\n\r\n  /*\r\n   * Move adjacent neurons by precomputed alpha*(1-((i-j)^2/[r]^2)) in\r\n   * radpower[|i-j|]\r\n   * ---------------------------------------------------------------------------------\r\n   */\r\n\r\n  var alterneigh = function alterneigh(rad, i, b, g, r) {\r\n\r\n    var j;\r\n    var k;\r\n    var lo;\r\n    var hi;\r\n    var a;\r\n    var m;\r\n    var p;\r\n\r\n    lo = i - rad;\r\n    if (lo < -1) lo = -1;\r\n\r\n    hi = i + rad;\r\n    if (hi > netsize) hi = netsize;\r\n\r\n    j = i + 1;\r\n    k = i - 1;\r\n    m = 1;\r\n\r\n    while ((j < hi) || (k > lo)) {\r\n      a = radpower[m++];\r\n\r\n      if (j < hi) {\r\n        p = network[j++];\r\n\r\n        try {\r\n          p[0] -= (a * (p[0] - b)) / alpharadbias;\r\n          p[1] -= (a * (p[1] - g)) / alpharadbias;\r\n          p[2] -= (a * (p[2] - r)) / alpharadbias;\r\n        } catch (e) {} // prevents 1.3 miscompilation\r\n      }\r\n\r\n      if (k > lo) {\r\n        p = network[k--];\r\n\r\n        try {\r\n          p[0] -= (a * (p[0] - b)) / alpharadbias;\r\n          p[1] -= (a * (p[1] - g)) / alpharadbias;\r\n          p[2] -= (a * (p[2] - r)) / alpharadbias;\r\n        } catch (e) {}\r\n      }\r\n    }\r\n  };\r\n\r\n  /*\r\n   * Move neuron i towards biased (b,g,r) by factor alpha\r\n   * ----------------------------------------------------\r\n   */\r\n\r\n  var altersingle = function altersingle(alpha, i, b, g, r) {\r\n\r\n    /* alter hit neuron */\r\n    var n = network[i];\r\n    n[0] -= (alpha * (n[0] - b)) / initalpha;\r\n    n[1] -= (alpha * (n[1] - g)) / initalpha;\r\n    n[2] -= (alpha * (n[2] - r)) / initalpha;\r\n  };\r\n\r\n  /*\r\n   * Search for biased BGR values ----------------------------\r\n   */\r\n\r\n  var contest = function contest(b, g, r) {\r\n\r\n    /* finds closest neuron (min dist) and updates freq */\r\n    /* finds best neuron (min dist-bias) and returns position */\r\n    /* for frequently chosen neurons, freq[i] is high and bias[i] is negative */\r\n    /* bias[i] = gamma*((1/netsize)-freq[i]) */\r\n\r\n    var i;\r\n    var dist;\r\n    var a;\r\n    var biasdist;\r\n    var betafreq;\r\n    var bestpos;\r\n    var bestbiaspos;\r\n    var bestd;\r\n    var bestbiasd;\r\n    var n;\r\n\r\n    bestd = ~ (1 << 31);\r\n    bestbiasd = bestd;\r\n    bestpos = -1;\r\n    bestbiaspos = bestpos;\r\n\r\n    for (i = 0; i < netsize; i++) {\r\n      n = network[i];\r\n      dist = n[0] - b;\r\n      if (dist < 0) dist = -dist;\r\n      a = n[1] - g;\r\n      if (a < 0) a = -a;\r\n      dist += a;\r\n      a = n[2] - r;\r\n      if (a < 0) a = -a;\r\n      dist += a;\r\n\r\n      if (dist < bestd) {\r\n        bestd = dist;\r\n        bestpos = i;\r\n      }\r\n\r\n      biasdist = dist - ((bias[i]) >> (intbiasshift - netbiasshift));\r\n\r\n      if (biasdist < bestbiasd) {\r\n        bestbiasd = biasdist;\r\n        bestbiaspos = i;\r\n      }\r\n\r\n      betafreq = (freq[i] >> betashift);\r\n      freq[i] -= betafreq;\r\n      bias[i] += (betafreq << gammashift);\r\n    }\r\n\r\n    freq[bestpos] += beta;\r\n    bias[bestpos] -= betagamma;\r\n    return (bestbiaspos);\r\n  };\r\n\r\n  NeuQuant.apply(this, arguments);\r\n  return exports;\r\n};\n\n/* eslint-disable */\r\n/**\r\n * This class handles LZW encoding\r\n * Adapted from Jef Poskanzer's Java port by way of J. M. G. Elliott.\r\n * @author Kevin Weiner (original Java version - kweiner@fmsware.com)\r\n * @author Thibault Imbert (AS3 version - bytearray.org)\r\n * @author Kevin Kwok (JavaScript version - https://github.com/antimatter15/jsgif)\r\n * @version 0.1 AS3 implementation\r\n */\r\n\r\nvar LZWEncoder = function() {\r\n\r\n  var exports = {};\r\n  var EOF = -1;\r\n  var imgW;\r\n  var imgH;\r\n  var pixAry;\r\n  var initCodeSize;\r\n  var remaining;\r\n  var curPixel;\r\n\r\n  // GIFCOMPR.C - GIF Image compression routines\r\n  // Lempel-Ziv compression based on 'compress'. GIF modifications by\r\n  // David Rowley (mgardi@watdcsu.waterloo.edu)\r\n  // General DEFINEs\r\n\r\n  var BITS = 12;\r\n  var HSIZE = 5003; // 80% occupancy\r\n\r\n  // GIF Image compression - modified 'compress'\r\n  // Based on: compress.c - File compression ala IEEE Computer, June 1984.\r\n  // By Authors: Spencer W. Thomas (decvax!harpo!utah-cs!utah-gr!thomas)\r\n  // Jim McKie (decvax!mcvax!jim)\r\n  // Steve Davies (decvax!vax135!petsd!peora!srd)\r\n  // Ken Turkowski (decvax!decwrl!turtlevax!ken)\r\n  // James A. Woods (decvax!ihnp4!ames!jaw)\r\n  // Joe Orost (decvax!vax135!petsd!joe)\r\n\r\n  var n_bits; // number of bits/code\r\n  var maxbits = BITS; // user settable max # bits/code\r\n  var maxcode; // maximum code, given n_bits\r\n  var maxmaxcode = 1 << BITS; // should NEVER generate this code\r\n  var htab = [];\r\n  var codetab = [];\r\n  var hsize = HSIZE; // for dynamic table sizing\r\n  var free_ent = 0; // first unused entry\r\n\r\n  // block compression parameters -- after all codes are used up,\r\n  // and compression rate changes, start over.\r\n\r\n  var clear_flg = false;\r\n\r\n  // Algorithm: use open addressing double hashing (no chaining) on the\r\n  // prefix code / next character combination. We do a variant of Knuth's\r\n  // algorithm D (vol. 3, sec. 6.4) along with G. Knott's relatively-prime\r\n  // secondary probe. Here, the modular division first probe is gives way\r\n  // to a faster exclusive-or manipulation. Also do block compression with\r\n  // an adaptive reset, whereby the code table is cleared when the compression\r\n  // ratio decreases, but after the table fills. The variable-length output\r\n  // codes are re-sized at this point, and a special CLEAR code is generated\r\n  // for the decompressor. Late addition: construct the table according to\r\n  // file size for noticeable speed improvement on small files. Please direct\r\n  // questions about this implementation to ames!jaw.\r\n\r\n  var g_init_bits;\r\n  var ClearCode;\r\n  var EOFCode;\r\n\r\n  // output\r\n  // Output the given code.\r\n  // Inputs:\r\n  // code: A n_bits-bit integer. If == -1, then EOF. This assumes\r\n  // that n_bits =< wordsize - 1.\r\n  // Outputs:\r\n  // Outputs code to the file.\r\n  // Assumptions:\r\n  // Chars are 8 bits long.\r\n  // Algorithm:\r\n  // Maintain a BITS character long buffer (so that 8 codes will\r\n  // fit in it exactly). Use the VAX insv instruction to insert each\r\n  // code in turn. When the buffer fills up empty it and start over.\r\n\r\n  var cur_accum = 0;\r\n  var cur_bits = 0;\r\n  var masks = [0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF, 0x01FF, 0x03FF, 0x07FF, 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF];\r\n\r\n  // Number of characters so far in this 'packet'\r\n  var a_count;\r\n\r\n  // Define the storage for the packet accumulator\r\n  var accum = [];\r\n\r\n  var LZWEncoder = exports.LZWEncoder = function LZWEncoder(width, height, pixels, color_depth) {\r\n    imgW = width;\r\n    imgH = height;\r\n    pixAry = pixels;\r\n    initCodeSize = Math.max(2, color_depth);\r\n  };\r\n\r\n  // Add a character to the end of the current packet, and if it is 254\r\n  // characters, flush the packet to disk.\r\n  var char_out = function char_out(c, outs) {\r\n    accum[a_count++] = c;\r\n    if (a_count >= 254) flush_char(outs);\r\n  };\r\n\r\n  // Clear out the hash table\r\n  // table clear for block compress\r\n\r\n  var cl_block = function cl_block(outs) {\r\n    cl_hash(hsize);\r\n    free_ent = ClearCode + 2;\r\n    clear_flg = true;\r\n    output(ClearCode, outs);\r\n  };\r\n\r\n  // reset code table\r\n  var cl_hash = function cl_hash(hsize) {\r\n    for (var i = 0; i < hsize; ++i) htab[i] = -1;\r\n  };\r\n\r\n  var compress = exports.compress = function compress(init_bits, outs) {\r\n\r\n    var fcode;\r\n    var i; /* = 0 */\r\n    var c;\r\n    var ent;\r\n    var disp;\r\n    var hsize_reg;\r\n    var hshift;\r\n\r\n    // Set up the globals: g_init_bits - initial number of bits\r\n    g_init_bits = init_bits;\r\n\r\n    // Set up the necessary values\r\n    clear_flg = false;\r\n    n_bits = g_init_bits;\r\n    maxcode = MAXCODE(n_bits);\r\n\r\n    ClearCode = 1 << (init_bits - 1);\r\n    EOFCode = ClearCode + 1;\r\n    free_ent = ClearCode + 2;\r\n\r\n    a_count = 0; // clear packet\r\n\r\n    ent = nextPixel();\r\n\r\n    hshift = 0;\r\n    for (fcode = hsize; fcode < 65536; fcode *= 2)\r\n      ++hshift;\r\n    hshift = 8 - hshift; // set hash code range bound\r\n\r\n    hsize_reg = hsize;\r\n    cl_hash(hsize_reg); // clear hash table\r\n\r\n    output(ClearCode, outs);\r\n\r\n    outer_loop: while ((c = nextPixel()) != EOF) {\r\n      fcode = (c << maxbits) + ent;\r\n      i = (c << hshift) ^ ent; // xor hashing\r\n\r\n      if (htab[i] == fcode) {\r\n        ent = codetab[i];\r\n        continue;\r\n      }\r\n\r\n      else if (htab[i] >= 0) { // non-empty slot\r\n\r\n        disp = hsize_reg - i; // secondary hash (after G. Knott)\r\n        if (i === 0) disp = 1;\r\n\r\n        do {\r\n          if ((i -= disp) < 0)\r\n            i += hsize_reg;\r\n\r\n          if (htab[i] == fcode) {\r\n            ent = codetab[i];\r\n            continue outer_loop;\r\n          }\r\n        } while (htab[i] >= 0);\r\n      }\r\n\r\n      output(ent, outs);\r\n      ent = c;\r\n      if (free_ent < maxmaxcode) {\r\n        codetab[i] = free_ent++; // code -> hashtable\r\n        htab[i] = fcode;\r\n      }\r\n      else cl_block(outs);\r\n    }\r\n\r\n                // Put out the final code.\r\n                output(ent, outs);\r\n                output(EOFCode, outs);\r\n  };\r\n\r\n  // ----------------------------------------------------------------------------\r\n  var encode = exports.encode = function encode(os) {\r\n    os.writeByte(initCodeSize); // write \"initial code size\" byte\r\n    remaining = imgW * imgH; // reset navigation variables\r\n    curPixel = 0;\r\n    compress(initCodeSize + 1, os); // compress and write the pixel data\r\n    os.writeByte(0); // write block terminator\r\n  };\r\n\r\n  // Flush the packet to disk, and reset the accumulator\r\n  var flush_char = function flush_char(outs) {\r\n    if (a_count > 0) {\r\n      outs.writeByte(a_count);\r\n      outs.writeBytes(accum, 0, a_count);\r\n      a_count = 0;\r\n    }\r\n  };\r\n\r\n  var MAXCODE = function MAXCODE(n_bits) {\r\n    return (1 << n_bits) - 1;\r\n  };\r\n\r\n  // ----------------------------------------------------------------------------\r\n  // Return the next pixel from the image\r\n  // ----------------------------------------------------------------------------\r\n\r\n  var nextPixel = function nextPixel() {\r\n    if (remaining === 0) return EOF;\r\n    --remaining;\r\n    var pix = pixAry[curPixel++];\r\n    return pix & 0xff;\r\n  };\r\n\r\n  var output = function output(code, outs) {\r\n\r\n    cur_accum &= masks[cur_bits];\r\n\r\n    if (cur_bits > 0) cur_accum |= (code << cur_bits);\r\n    else cur_accum = code;\r\n\r\n    cur_bits += n_bits;\r\n\r\n    while (cur_bits >= 8) {\r\n      char_out((cur_accum & 0xff), outs);\r\n      cur_accum >>= 8;\r\n      cur_bits -= 8;\r\n    }\r\n\r\n    // If the next entry is going to be too big for the code size,\r\n    // then increase it, if possible.\r\n\r\n    if (free_ent > maxcode || clear_flg) {\r\n\r\n      if (clear_flg) {\r\n\r\n        maxcode = MAXCODE(n_bits = g_init_bits);\r\n        clear_flg = false;\r\n\r\n      } else {\r\n\r\n        ++n_bits;\r\n        if (n_bits == maxbits) maxcode = maxmaxcode;\r\n        else maxcode = MAXCODE(n_bits);\r\n      }\r\n    }\r\n\r\n    if (code == EOFCode) {\r\n\r\n      // At EOF, write the rest of the buffer.\r\n      while (cur_bits > 0) {\r\n        char_out((cur_accum & 0xff), outs);\r\n        cur_accum >>= 8;\r\n        cur_bits -= 8;\r\n      }\r\n\r\n      flush_char(outs);\r\n    }\r\n  };\r\n\r\n  LZWEncoder.apply(this, arguments);\r\n  return exports;\r\n};\n\n/* eslint-disable */\r\n\r\nvar GIFEncoder = function() {\r\n\r\n  for (var i = 0, chr = {}; i < 256; i++)\r\n    chr[i] = String.fromCharCode(i);\r\n\r\n  function ByteArray() {\r\n    this.bin = [];\r\n  }\r\n\r\n  ByteArray.prototype.getData = function() {\r\n    for (var v = '', l = this.bin.length, i = 0; i < l; i++)\r\n      v += chr[this.bin[i]];\r\n    return v;\r\n  };\r\n\r\n  ByteArray.prototype.getUnit8Array = function() {\r\n    var arr = new Uint8Array(this.bin.length);\r\n    for (var l = this.bin.length, i = 0; i < l; i++)\r\n      arr[i] = this.bin[i];\r\n    return arr;\r\n  };\r\n\r\n  ByteArray.prototype.writeByte = function(val) {\r\n    this.bin.push(val);\r\n  };\r\n\r\n  ByteArray.prototype.writeUTFBytes = function(string) {\r\n    for (var l = string.length, i = 0; i < l; i++)\r\n      this.writeByte(string.charCodeAt(i));\r\n  };\r\n\r\n  ByteArray.prototype.writeBytes = function(array, offset, length) {\r\n    for (var l = length || array.length, i = offset || 0; i < l; i++)\r\n      this.writeByte(array[i]);\r\n  };\r\n\r\n  var exports = {};\r\n  var width; // image size\r\n  var height;\r\n  var transparent = null; // transparent color if given\r\n  var transIndex; // transparent index in color table\r\n  var repeat = -1; // no repeat\r\n  var delay = 0; // frame delay (hundredths)\r\n  var started = false; // ready to output frames\r\n  var out;\r\n  var image; // current frame\r\n  var pixels; // BGR byte array from frame\r\n  var indexedPixels; // converted frame indexed to palette\r\n  var colorDepth; // number of bit planes\r\n  var colorTab; // RGB palette\r\n  var usedEntry = []; // active palette entries\r\n  var palSize = 7; // color table size (bits-1)\r\n  var dispose = -1; // disposal code (-1 = use default)\r\n  var firstFrame = true;\r\n  var sizeSet = false; // if false, get size from first frame\r\n  var sample = 10; // default sample interval for quantizer\r\n  var comment = \"Generated by jsgif (https://github.com/antimatter15/jsgif/)\"; // default comment for generated gif\r\n\r\n  /**\r\n   * Sets the delay time between each frame, or changes it for subsequent frames\r\n   * (applies to last frame added)\r\n   * int delay time in milliseconds\r\n   * @param ms\r\n   */\r\n\r\n  var setDelay = exports.setDelay = function setDelay(ms) {\r\n    delay = Math.round(ms / 10);\r\n  };\r\n\r\n  /**\r\n   * Sets the GIF frame disposal code for the last added frame and any\r\n   *\r\n   * subsequent frames. Default is 0 if no transparent color has been set,\r\n   * otherwise 2.\r\n   * @param code\r\n   * int disposal code.\r\n   */\r\n\r\n  var setDispose = exports.setDispose = function setDispose(code) {\r\n    if (code >= 0) dispose = code;\r\n  };\r\n\r\n  /**\r\n   * Sets the number of times the set of GIF frames should be played. Default is\r\n   * 1; 0 means play indefinitely. Must be invoked before the first image is\r\n   * added.\r\n   *\r\n   * @param iter\r\n   * int number of iterations.\r\n   * @return\r\n   */\r\n\r\n  var setRepeat = exports.setRepeat = function setRepeat(iter) {\r\n    if (iter >= 0) repeat = iter;\r\n  };\r\n\r\n  /**\r\n   * Sets the transparent color for the last added frame and any subsequent\r\n   * frames. Since all colors are subject to modification in the quantization\r\n   * process, the color in the final palette for each frame closest to the given\r\n   * color becomes the transparent color for that frame. May be set to null to\r\n   * indicate no transparent color.\r\n   * @param\r\n   * Color to be treated as transparent on display.\r\n   */\r\n\r\n  var setTransparent = exports.setTransparent = function setTransparent(c) {\r\n    transparent = c;\r\n  };\r\n\r\n\r\n  /**\r\n   * Sets the comment for the block comment\r\n   * @param\r\n   * string to be insterted as comment\r\n   */\r\n\r\n  var setComment = exports.setComment = function setComment(c) {\r\n    comment = c;\r\n  };\r\n\r\n\r\n\r\n  /**\r\n   * The addFrame method takes an incoming BitmapData object to create each frames\r\n   * @param\r\n   * BitmapData object to be treated as a GIF's frame\r\n   */\r\n\r\n  var addFrame = exports.addFrame = function addFrame(im, is_imageData) {\r\n\r\n    if ((im === null) || !started || out === null) {\r\n      throw new Error(\"Please call start method before calling addFrame\");\r\n    }\r\n\r\n    var ok = true;\r\n\r\n    try {\r\n      if (!is_imageData) {\r\n        image = im.getImageData(0, 0, im.canvas.width, im.canvas.height).data;\r\n        if (!sizeSet) setSize(im.canvas.width, im.canvas.height);\r\n      } else {\r\n        image = im;\r\n      }\r\n      getImagePixels(); // convert to correct format if necessary\r\n      analyzePixels(); // build color table & map pixels\r\n\r\n      if (firstFrame) {\r\n        writeLSD(); // logical screen descriptior\r\n        writePalette(); // global color table\r\n        if (repeat >= 0) {\r\n          // use NS app extension to indicate reps\r\n          writeNetscapeExt();\r\n        }\r\n      }\r\n\r\n      writeGraphicCtrlExt(); // write graphic control extension\r\n      if (comment !== '') {\r\n        writeCommentExt(); // write comment extension\r\n      }\r\n      writeImageDesc(); // image descriptor\r\n      if (!firstFrame) writePalette(); // local color table\r\n      writePixels(); // encode and write pixel data\r\n      firstFrame = false;\r\n    } catch (e) {\r\n      ok = false;\r\n    }\r\n\r\n    return ok;\r\n  };\r\n\r\n  /**\r\n   * Adds final trailer to the GIF stream, if you don't call the finish method\r\n   * the GIF stream will not be valid.\r\n   */\r\n\r\n  var finish = exports.finish = function finish() {\r\n\r\n    if (!started) return false;\r\n\r\n    var ok = true;\r\n    started = false;\r\n\r\n    try {\r\n      out.writeByte(0x3b); // gif trailer\r\n    } catch (e) {\r\n      ok = false;\r\n    }\r\n\r\n    return ok;\r\n  };\r\n\r\n  /**\r\n   * Resets some members so that a new stream can be started.\r\n   * This method is actually called by the start method\r\n   */\r\n\r\n  var reset = function reset() {\r\n\r\n    // reset for subsequent use\r\n    transIndex = 0;\r\n    image = null;\r\n    pixels = null;\r\n    indexedPixels = null;\r\n    colorTab = null;\r\n    firstFrame = true;\r\n  };\r\n\r\n  /**\r\n   * * Sets frame rate in frames per second. Equivalent to\r\n   * <code>setDelay(1000/fps)</code>.\r\n   * @param fps\r\n   * float frame rate (frames per second)\r\n   */\r\n\r\n  var setFrameRate = exports.setFrameRate = function setFrameRate(fps) {\r\n    if (fps != 0xf) delay = Math.round(100 / fps);\r\n  };\r\n\r\n  /**\r\n   * Sets quality of color quantization (conversion of images to the maximum 256\r\n   * colors allowed by the GIF specification). Lower values (minimum = 1)\r\n   * produce better colors, but slow processing significantly. 10 is the\r\n   * default, and produces good color mapping at reasonable speeds. Values\r\n   * greater than 20 do not yield significant improvements in speed.\r\n   * @param quality\r\n   * int greater than 0.\r\n   * @return\r\n   */\r\n\r\n  var setQuality = exports.setQuality = function setQuality(quality) {\r\n    if (quality < 1) quality = 1;\r\n    sample = quality;\r\n  };\r\n\r\n  /**\r\n   * Sets the GIF frame size. The default size is the size of the first frame\r\n   * added if this method is not invoked.\r\n   * @param w\r\n   * int frame width.\r\n   * @param h\r\n   * int frame width.\r\n   */\r\n\r\n  var setSize = exports.setSize = function setSize(w, h) {\r\n\r\n    if (started && !firstFrame) return;\r\n    width = w;\r\n    height = h;\r\n    if (width < 1) width = 320;\r\n    if (height < 1) height = 240;\r\n    sizeSet = true;\r\n  };\r\n\r\n  /**\r\n   * Initiates GIF file creation on the given stream.\r\n   * @param os\r\n   * OutputStream on which GIF images are written.\r\n   * @return false if initial write failed.\r\n   */\r\n\r\n  var start = exports.start = function start() {\r\n\r\n    reset();\r\n    var ok = true;\r\n    out = new ByteArray();\r\n    try {\r\n      out.writeUTFBytes(\"GIF89a\"); // header\r\n    } catch (e) {\r\n      ok = false;\r\n    }\r\n\r\n    return started = ok;\r\n  };\r\n\r\n  var cont = exports.cont = function cont() {\r\n\r\n    reset();\r\n    var ok = true;\r\n    out = new ByteArray();\r\n\r\n    return started = ok;\r\n  };\r\n\r\n  /**\r\n   * Analyzes image colors and creates color map.\r\n   */\r\n\r\n  var analyzePixels = function analyzePixels() {\r\n\r\n    var len = pixels.length;\r\n    var nPix = len / 3;\r\n    indexedPixels = [];\r\n    var nq = new NeuQuant(pixels, len, sample);\r\n\r\n    // initialize quantizer\r\n    colorTab = nq.process(); // create reduced palette\r\n\r\n    // map image pixels to new palette\r\n    var k = 0;\r\n    for (var j = 0; j < nPix; j++) {\r\n      var index = nq.map(pixels[k++] & 0xff, pixels[k++] & 0xff, pixels[k++] & 0xff);\r\n      usedEntry[index] = true;\r\n      indexedPixels[j] = index;\r\n    }\r\n\r\n    pixels = null;\r\n    colorDepth = 8;\r\n    palSize = 7;\r\n\r\n    // get closest match to transparent color if specified\r\n    if (transparent !== null) {\r\n      transIndex = findClosest(transparent);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Returns index of palette color closest to c\r\n   */\r\n\r\n  var findClosest = function findClosest(c) {\r\n\r\n    if (colorTab === null) return -1;\r\n    var r = (c & 0xFF0000) >> 16;\r\n    var g = (c & 0x00FF00) >> 8;\r\n    var b = (c & 0x0000FF);\r\n    var minpos = 0;\r\n    var dmin = 256 * 256 * 256;\r\n    var len = colorTab.length;\r\n\r\n    for (var i = 0; i < len;) {\r\n      var dr = r - (colorTab[i++] & 0xff);\r\n      var dg = g - (colorTab[i++] & 0xff);\r\n      var db = b - (colorTab[i] & 0xff);\r\n      var d = dr * dr + dg * dg + db * db;\r\n      var index = i / 3;\r\n      if (usedEntry[index] && (d < dmin)) {\r\n        dmin = d;\r\n        minpos = index;\r\n      }\r\n      i++;\r\n    }\r\n    return minpos;\r\n  };\r\n\r\n  /**\r\n   * Extracts image pixels into byte array \"pixels\r\n   */\r\n\r\n  var getImagePixels = function getImagePixels() {\r\n    var w = width;\r\n    var h = height;\r\n    pixels = [];\r\n    var data = image;\r\n    var count = 0;\r\n\r\n    for (var i = 0; i < h; i++) {\r\n\r\n      for (var j = 0; j < w; j++) {\r\n\r\n        var b = (i * w * 4) + j * 4;\r\n        pixels[count++] = data[b];\r\n        pixels[count++] = data[b + 1];\r\n        pixels[count++] = data[b + 2];\r\n\r\n      }\r\n\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Writes Graphic Control Extension\r\n   */\r\n\r\n  var writeGraphicCtrlExt = function writeGraphicCtrlExt() {\r\n    out.writeByte(0x21); // extension introducer\r\n    out.writeByte(0xf9); // GCE label\r\n    out.writeByte(4); // data block size\r\n    var transp;\r\n    var disp;\r\n    if (transparent === null) {\r\n      transp = 0;\r\n      disp = 0; // dispose = no action\r\n    } else {\r\n      transp = 1;\r\n      disp = 2; // force clear if using transparent color\r\n    }\r\n    if (dispose >= 0) {\r\n      disp = dispose & 7; // user override\r\n    }\r\n    disp <<= 2;\r\n    // packed fields\r\n    out.writeByte(0 | // 1:3 reserved\r\n        disp | // 4:6 disposal\r\n        0 | // 7 user input - 0 = none\r\n        transp); // 8 transparency flag\r\n\r\n    WriteShort(delay); // delay x 1/100 sec\r\n    out.writeByte(transIndex); // transparent color index\r\n    out.writeByte(0); // block terminator\r\n  };\r\n\r\n  /**\r\n   * Writes Comment Extention\r\n   */\r\n\r\n  var writeCommentExt = function writeCommentExt() {\r\n    out.writeByte(0x21); // extension introducer\r\n    out.writeByte(0xfe); // comment label\r\n    out.writeByte(comment.length); // Block Size (s)\r\n    out.writeUTFBytes(comment);\r\n    out.writeByte(0); // block terminator\r\n  };\r\n\r\n\r\n  /**\r\n   * Writes Image Descriptor\r\n   */\r\n\r\n  var writeImageDesc = function writeImageDesc() {\r\n\r\n    out.writeByte(0x2c); // image separator\r\n    WriteShort(0); // image position x,y = 0,0\r\n    WriteShort(0);\r\n    WriteShort(width); // image size\r\n    WriteShort(height);\r\n\r\n    // packed fields\r\n    if (firstFrame) {\r\n      // no LCT - GCT is used for first (or only) frame\r\n      out.writeByte(0);\r\n    } else {\r\n      // specify normal LCT\r\n      out.writeByte(0x80 | // 1 local color table 1=yes\r\n          0 | // 2 interlace - 0=no\r\n          0 | // 3 sorted - 0=no\r\n          0 | // 4-5 reserved\r\n          palSize); // 6-8 size of color table\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Writes Logical Screen Descriptor\r\n   */\r\n\r\n  var writeLSD = function writeLSD() {\r\n\r\n    // logical screen size\r\n    WriteShort(width);\r\n    WriteShort(height);\r\n    // packed fields\r\n    out.writeByte((0x80 | // 1 : global color table flag = 1 (gct used)\r\n          0x70 | // 2-4 : color resolution = 7\r\n          0x00 | // 5 : gct sort flag = 0\r\n          palSize)); // 6-8 : gct size\r\n\r\n    out.writeByte(0); // background color index\r\n    out.writeByte(0); // pixel aspect ratio - assume 1:1\r\n  };\r\n\r\n  /**\r\n   * Writes Netscape application extension to define repeat count.\r\n   */\r\n\r\n  var writeNetscapeExt = function writeNetscapeExt() {\r\n    out.writeByte(0x21); // extension introducer\r\n    out.writeByte(0xff); // app extension label\r\n    out.writeByte(11); // block size\r\n    out.writeUTFBytes(\"NETSCAPE\" + \"2.0\"); // app id + auth code\r\n    out.writeByte(3); // sub-block size\r\n    out.writeByte(1); // loop sub-block id\r\n    WriteShort(repeat); // loop count (extra iterations, 0=repeat forever)\r\n    out.writeByte(0); // block terminator\r\n  };\r\n\r\n  /**\r\n   * Writes color table\r\n   */\r\n\r\n  var writePalette = function writePalette() {\r\n    out.writeBytes(colorTab);\r\n    var n = (3 * 256) - colorTab.length;\r\n    for (var i = 0; i < n; i++) out.writeByte(0);\r\n  };\r\n\r\n  var WriteShort = function WriteShort(pValue) {\r\n    out.writeByte(pValue & 0xFF);\r\n    out.writeByte((pValue >> 8) & 0xFF);\r\n  };\r\n\r\n  /**\r\n   * Encodes and writes pixel data\r\n   */\r\n\r\n  var writePixels = function writePixels() {\r\n    var myencoder = new LZWEncoder(width, height, indexedPixels, colorDepth);\r\n    myencoder.encode(out);\r\n  };\r\n\r\n  /**\r\n   * Retrieves the GIF stream\r\n   */\r\n\r\n  var stream = exports.stream = function stream() {\r\n    return out;\r\n  };\r\n\r\n  var setProperties = exports.setProperties = function setProperties(has_start, is_first) {\r\n    started = has_start;\r\n    firstFrame = is_first;\r\n  };\r\n\r\n  return exports;\r\n\r\n};\n\n// (c) Dean McNamee <dean@gmail.com>, 2013.\r\n\r\n\r\nfunction GifReader(buf) {\r\n  var p = 0;\r\n\r\n  // - Header (GIF87a or GIF89a).\r\n  if (buf[p++] !== 0x47 ||            buf[p++] !== 0x49 || buf[p++] !== 0x46 ||\r\n      buf[p++] !== 0x38 || (buf[p++]+1 & 0xfd) !== 0x38 || buf[p++] !== 0x61) {\r\n    throw new Error(\"Invalid GIF 87a/89a header.\");\r\n  }\r\n\r\n  // - Logical Screen Descriptor.\r\n  var width = buf[p++] | buf[p++] << 8;\r\n  var height = buf[p++] | buf[p++] << 8;\r\n  var pf0 = buf[p++];  // <Packed Fields>.\r\n  var global_palette_flag = pf0 >> 7;\r\n  var num_global_colors_pow2 = pf0 & 0x7;\r\n  var num_global_colors = 1 << (num_global_colors_pow2 + 1);\r\n  var background = buf[p++];\r\n  buf[p++];  // Pixel aspect ratio (unused?).\r\n\r\n  var global_palette_offset = null;\r\n  var global_palette_size   = null;\r\n\r\n  if (global_palette_flag) {\r\n    global_palette_offset = p;\r\n    global_palette_size = num_global_colors;\r\n    p += num_global_colors * 3;  // Seek past palette.\r\n  }\r\n\r\n  var no_eof = true;\r\n\r\n  var frames = [ ];\r\n\r\n  var delay = 0;\r\n  var transparent_index = null;\r\n  var disposal = 0;  // 0 - No disposal specified.\r\n  var loop_count = null;\r\n\r\n  this.width = width;\r\n  this.height = height;\r\n\r\n  while (no_eof && p < buf.length) {\r\n    switch (buf[p++]) {\r\n      case 0x21:  // Graphics Control Extension Block\r\n        switch (buf[p++]) {\r\n          case 0xff:  // Application specific block\r\n            // Try if it's a Netscape block (with animation loop counter).\r\n            if (buf[p   ] !== 0x0b ||  // 21 FF already read, check block size.\r\n                // NETSCAPE2.0\r\n                buf[p+1 ] == 0x4e && buf[p+2 ] == 0x45 && buf[p+3 ] == 0x54 &&\r\n                buf[p+4 ] == 0x53 && buf[p+5 ] == 0x43 && buf[p+6 ] == 0x41 &&\r\n                buf[p+7 ] == 0x50 && buf[p+8 ] == 0x45 && buf[p+9 ] == 0x32 &&\r\n                buf[p+10] == 0x2e && buf[p+11] == 0x30 &&\r\n                // Sub-block\r\n                buf[p+12] == 0x03 && buf[p+13] == 0x01 && buf[p+16] == 0) {\r\n              p += 14;\r\n              loop_count = buf[p++] | buf[p++] << 8;\r\n              p++;  // Skip terminator.\r\n            } else {  // We don't know what it is, just try to get past it.\r\n              p += 12;\r\n              while (true) {  // Seek through subblocks.\r\n                var block_size = buf[p++];\r\n                // Bad block size (ex: undefined from an out of bounds read).\r\n                if (!(block_size >= 0)) throw Error(\"Invalid block size\");\r\n                if (block_size === 0) break;  // 0 size is terminator\r\n                p += block_size;\r\n              }\r\n            }\r\n            break;\r\n\r\n          case 0xf9:  // Graphics Control Extension\r\n            if (buf[p++] !== 0x4 || buf[p+4] !== 0)\r\n              throw new Error(\"Invalid graphics extension block.\");\r\n            var pf1 = buf[p++];\r\n            delay = buf[p++] | buf[p++] << 8;\r\n            transparent_index = buf[p++];\r\n            if ((pf1 & 1) === 0) transparent_index = null;\r\n            disposal = pf1 >> 2 & 0x7;\r\n            p++;  // Skip terminator.\r\n            break;\r\n\r\n          // Plain Text Extension could be present and we just want to be able\r\n          // to parse past it.  It follows the block structure of the comment\r\n          // extension enough to reuse the path to skip through the blocks.\r\n          case 0x01:  // Plain Text Extension (fallthrough to Comment Extension)\r\n          case 0xfe:  // Comment Extension.\r\n            while (true) {  // Seek through subblocks.\r\n              var block_size = buf[p++];\r\n              // Bad block size (ex: undefined from an out of bounds read).\r\n              if (!(block_size >= 0)) throw Error(\"Invalid block size\");\r\n              if (block_size === 0) break;  // 0 size is terminator\r\n              // console.log(buf.slice(p, p+block_size).toString('ascii'));\r\n              p += block_size;\r\n            }\r\n            break;\r\n\r\n          default:\r\n            throw new Error(\r\n                \"Unknown graphic control label: 0x\" + buf[p-1].toString(16));\r\n        }\r\n        break;\r\n\r\n      case 0x2c:  // Image Descriptor.\r\n        var x = buf[p++] | buf[p++] << 8;\r\n        var y = buf[p++] | buf[p++] << 8;\r\n        var w = buf[p++] | buf[p++] << 8;\r\n        var h = buf[p++] | buf[p++] << 8;\r\n        var pf2 = buf[p++];\r\n        var local_palette_flag = pf2 >> 7;\r\n        var interlace_flag = pf2 >> 6 & 1;\r\n        var num_local_colors_pow2 = pf2 & 0x7;\r\n        var num_local_colors = 1 << (num_local_colors_pow2 + 1);\r\n        var palette_offset = global_palette_offset;\r\n        var palette_size = global_palette_size;\r\n        var has_local_palette = false;\r\n        if (local_palette_flag) {\r\n          var has_local_palette = true;\r\n          palette_offset = p;  // Override with local palette.\r\n          palette_size = num_local_colors;\r\n          p += num_local_colors * 3;  // Seek past palette.\r\n        }\r\n\r\n        var data_offset = p;\r\n\r\n        p++;  // codesize\r\n        while (true) {\r\n          var block_size = buf[p++];\r\n          // Bad block size (ex: undefined from an out of bounds read).\r\n          if (!(block_size >= 0)) throw Error(\"Invalid block size\");\r\n          if (block_size === 0) break;  // 0 size is terminator\r\n          p += block_size;\r\n        }\r\n\r\n        frames.push({x: x, y: y, width: w, height: h,\r\n                     has_local_palette: has_local_palette,\r\n                     palette_offset: palette_offset,\r\n                     palette_size: palette_size,\r\n                     data_offset: data_offset,\r\n                     data_length: p - data_offset,\r\n                     transparent_index: transparent_index,\r\n                     interlaced: !!interlace_flag,\r\n                     delay: delay,\r\n                     disposal: disposal});\r\n        break;\r\n\r\n      case 0x3b:  // Trailer Marker (end of file).\r\n        no_eof = false;\r\n        break;\r\n\r\n      default:\r\n        throw new Error(\"Unknown gif block: 0x\" + buf[p-1].toString(16));\r\n    }\r\n  }\r\n\r\n  this.numFrames = function() {\r\n    return frames.length;\r\n  };\r\n\r\n  this.loopCount = function() {\r\n    return loop_count;\r\n  };\r\n\r\n  this.frameInfo = function(frame_num) {\r\n    if (frame_num < 0 || frame_num >= frames.length)\r\n      throw new Error(\"Frame index out of range.\");\r\n    return frames[frame_num];\r\n  };\r\n\r\n  this.decodeAndBlitFrameBGRA = function(frame_num, pixels) {\r\n    var frame = this.frameInfo(frame_num);\r\n    var num_pixels = frame.width * frame.height;\r\n    var index_stream = new Uint8Array(num_pixels);  // At most 8-bit indices.\r\n    GifReaderLZWOutputIndexStream(\r\n        buf, frame.data_offset, index_stream, num_pixels);\r\n    var palette_offset = frame.palette_offset;\r\n\r\n    // NOTE(deanm): It seems to be much faster to compare index to 256 than\r\n    // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in\r\n    // the profile, not sure if it's related to using a Uint8Array.\r\n    var trans = frame.transparent_index;\r\n    if (trans === null) trans = 256;\r\n\r\n    // We are possibly just blitting to a portion of the entire frame.\r\n    // That is a subrect within the framerect, so the additional pixels\r\n    // must be skipped over after we finished a scanline.\r\n    var framewidth  = frame.width;\r\n    var framestride = width - framewidth;\r\n    var xleft       = framewidth;  // Number of subrect pixels left in scanline.\r\n\r\n    // Output index of the top left corner of the subrect.\r\n    var opbeg = ((frame.y * width) + frame.x) * 4;\r\n    // Output index of what would be the left edge of the subrect, one row\r\n    // below it, i.e. the index at which an interlace pass should wrap.\r\n    var opend = ((frame.y + frame.height) * width + frame.x) * 4;\r\n    var op    = opbeg;\r\n\r\n    var scanstride = framestride * 4;\r\n\r\n    // Use scanstride to skip past the rows when interlacing.  This is skipping\r\n    // 7 rows for the first two passes, then 3 then 1.\r\n    if (frame.interlaced === true) {\r\n      scanstride += width * 4 * 7;  // Pass 1.\r\n    }\r\n\r\n    var interlaceskip = 8;  // Tracking the row interval in the current pass.\r\n\r\n    for (var i = 0, il = index_stream.length; i < il; ++i) {\r\n      var index = index_stream[i];\r\n\r\n      if (xleft === 0) {  // Beginning of new scan line\r\n        op += scanstride;\r\n        xleft = framewidth;\r\n        if (op >= opend) { // Catch the wrap to switch passes when interlacing.\r\n          scanstride = framestride * 4 + width * 4 * (interlaceskip-1);\r\n          // interlaceskip / 2 * 4 is interlaceskip << 1.\r\n          op = opbeg + (framewidth + framestride) * (interlaceskip << 1);\r\n          interlaceskip >>= 1;\r\n        }\r\n      }\r\n\r\n      if (index === trans) {\r\n        op += 4;\r\n      } else {\r\n        var r = buf[palette_offset + index * 3];\r\n        var g = buf[palette_offset + index * 3 + 1];\r\n        var b = buf[palette_offset + index * 3 + 2];\r\n        pixels[op++] = b;\r\n        pixels[op++] = g;\r\n        pixels[op++] = r;\r\n        pixels[op++] = 255;\r\n      }\r\n      --xleft;\r\n    }\r\n  };\r\n\r\n  // I will go to copy and paste hell one day...\r\n  this.decodeAndBlitFrameRGBA = function(frame_num, pixels) {\r\n    var frame = this.frameInfo(frame_num);\r\n    var num_pixels = frame.width * frame.height;\r\n    var index_stream = new Uint8Array(num_pixels);  // At most 8-bit indices.\r\n    GifReaderLZWOutputIndexStream(\r\n        buf, frame.data_offset, index_stream, num_pixels);\r\n    var palette_offset = frame.palette_offset;\r\n\r\n    // NOTE(deanm): It seems to be much faster to compare index to 256 than\r\n    // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in\r\n    // the profile, not sure if it's related to using a Uint8Array.\r\n    var trans = frame.transparent_index;\r\n    if (trans === null) trans = 256;\r\n\r\n    // We are possibly just blitting to a portion of the entire frame.\r\n    // That is a subrect within the framerect, so the additional pixels\r\n    // must be skipped over after we finished a scanline.\r\n    var framewidth  = frame.width;\r\n    var framestride = width - framewidth;\r\n    var xleft       = framewidth;  // Number of subrect pixels left in scanline.\r\n\r\n    // Output index of the top left corner of the subrect.\r\n    var opbeg = ((frame.y * width) + frame.x) * 4;\r\n    // Output index of what would be the left edge of the subrect, one row\r\n    // below it, i.e. the index at which an interlace pass should wrap.\r\n    var opend = ((frame.y + frame.height) * width + frame.x) * 4;\r\n    var op    = opbeg;\r\n\r\n    var scanstride = framestride * 4;\r\n\r\n    // Use scanstride to skip past the rows when interlacing.  This is skipping\r\n    // 7 rows for the first two passes, then 3 then 1.\r\n    if (frame.interlaced === true) {\r\n      scanstride += width * 4 * 7;  // Pass 1.\r\n    }\r\n\r\n    var interlaceskip = 8;  // Tracking the row interval in the current pass.\r\n\r\n    for (var i = 0, il = index_stream.length; i < il; ++i) {\r\n      var index = index_stream[i];\r\n\r\n      if (xleft === 0) {  // Beginning of new scan line\r\n        op += scanstride;\r\n        xleft = framewidth;\r\n        if (op >= opend) { // Catch the wrap to switch passes when interlacing.\r\n          scanstride = framestride * 4 + width * 4 * (interlaceskip-1);\r\n          // interlaceskip / 2 * 4 is interlaceskip << 1.\r\n          op = opbeg + (framewidth + framestride) * (interlaceskip << 1);\r\n          interlaceskip >>= 1;\r\n        }\r\n      }\r\n\r\n      if (index === trans) {\r\n        op += 4;\r\n      } else {\r\n        var r = buf[palette_offset + index * 3];\r\n        var g = buf[palette_offset + index * 3 + 1];\r\n        var b = buf[palette_offset + index * 3 + 2];\r\n        pixels[op++] = r;\r\n        pixels[op++] = g;\r\n        pixels[op++] = b;\r\n        pixels[op++] = 255;\r\n      }\r\n      --xleft;\r\n    }\r\n  };\r\n}\r\n\r\nfunction GifReaderLZWOutputIndexStream(code_stream, p, output, output_length) {\r\n  var min_code_size = code_stream[p++];\r\n\r\n  var clear_code = 1 << min_code_size;\r\n  var eoi_code = clear_code + 1;\r\n  var next_code = eoi_code + 1;\r\n\r\n  var cur_code_size = min_code_size + 1;  // Number of bits per code.\r\n  // NOTE: This shares the same name as the encoder, but has a different\r\n  // meaning here.  Here this masks each code coming from the code stream.\r\n  var code_mask = (1 << cur_code_size) - 1;\r\n  var cur_shift = 0;\r\n  var cur = 0;\r\n\r\n  var op = 0;  // Output pointer.\r\n\r\n  var subblock_size = code_stream[p++];\r\n\r\n  // TODO(deanm): Would using a TypedArray be any faster?  At least it would\r\n  // solve the fast mode / backing store uncertainty.\r\n  // var code_table = Array(4096);\r\n  var code_table = new Int32Array(4096);  // Can be signed, we only use 20 bits.\r\n\r\n  var prev_code = null;  // Track code-1.\r\n\r\n  while (true) {\r\n    // Read up to two bytes, making sure we always 12-bits for max sized code.\r\n    while (cur_shift < 16) {\r\n      if (subblock_size === 0) break;  // No more data to be read.\r\n\r\n      cur |= code_stream[p++] << cur_shift;\r\n      cur_shift += 8;\r\n\r\n      if (subblock_size === 1) {  // Never let it get to 0 to hold logic above.\r\n        subblock_size = code_stream[p++];  // Next subblock.\r\n      } else {\r\n        --subblock_size;\r\n      }\r\n    }\r\n\r\n    // TODO(deanm): We should never really get here, we should have received\r\n    // and EOI.\r\n    if (cur_shift < cur_code_size)\r\n      break;\r\n\r\n    var code = cur & code_mask;\r\n    cur >>= cur_code_size;\r\n    cur_shift -= cur_code_size;\r\n\r\n    // TODO(deanm): Maybe should check that the first code was a clear code,\r\n    // at least this is what you're supposed to do.  But actually our encoder\r\n    // now doesn't emit a clear code first anyway.\r\n    if (code === clear_code) {\r\n      // We don't actually have to clear the table.  This could be a good idea\r\n      // for greater error checking, but we don't really do any anyway.  We\r\n      // will just track it with next_code and overwrite old entries.\r\n\r\n      next_code = eoi_code + 1;\r\n      cur_code_size = min_code_size + 1;\r\n      code_mask = (1 << cur_code_size) - 1;\r\n\r\n      // Don't update prev_code ?\r\n      prev_code = null;\r\n      continue;\r\n    } else if (code === eoi_code) {\r\n      break;\r\n    }\r\n\r\n    // We have a similar situation as the decoder, where we want to store\r\n    // variable length entries (code table entries), but we want to do in a\r\n    // faster manner than an array of arrays.  The code below stores sort of a\r\n    // linked list within the code table, and then \"chases\" through it to\r\n    // construct the dictionary entries.  When a new entry is created, just the\r\n    // last byte is stored, and the rest (prefix) of the entry is only\r\n    // referenced by its table entry.  Then the code chases through the\r\n    // prefixes until it reaches a single byte code.  We have to chase twice,\r\n    // first to compute the length, and then to actually copy the data to the\r\n    // output (backwards, since we know the length).  The alternative would be\r\n    // storing something in an intermediate stack, but that doesn't make any\r\n    // more sense.  I implemented an approach where it also stored the length\r\n    // in the code table, although it's a bit tricky because you run out of\r\n    // bits (12 + 12 + 8), but I didn't measure much improvements (the table\r\n    // entries are generally not the long).  Even when I created benchmarks for\r\n    // very long table entries the complexity did not seem worth it.\r\n    // The code table stores the prefix entry in 12 bits and then the suffix\r\n    // byte in 8 bits, so each entry is 20 bits.\r\n\r\n    var chase_code = code < next_code ? code : prev_code;\r\n\r\n    // Chase what we will output, either {CODE} or {CODE-1}.\r\n    var chase_length = 0;\r\n    var chase = chase_code;\r\n    while (chase > clear_code) {\r\n      chase = code_table[chase] >> 8;\r\n      ++chase_length;\r\n    }\r\n\r\n    var k = chase;\r\n\r\n    var op_end = op + chase_length + (chase_code !== code ? 1 : 0);\r\n    if (op_end > output_length) {\r\n      console.log(\"Warning, gif stream longer than expected.\");\r\n      return;\r\n    }\r\n\r\n    // Already have the first byte from the chase, might as well write it fast.\r\n    output[op++] = k;\r\n\r\n    op += chase_length;\r\n    var b = op;  // Track pointer, writing backwards.\r\n\r\n    if (chase_code !== code)  // The case of emitting {CODE-1} + k.\r\n      output[op++] = k;\r\n\r\n    chase = chase_code;\r\n    while (chase_length--) {\r\n      chase = code_table[chase];\r\n      output[--b] = chase & 0xff;  // Write backwards.\r\n      chase >>= 8;  // Pull down to the prefix code.\r\n    }\r\n\r\n    if (prev_code !== null && next_code < 4096) {\r\n      code_table[next_code++] = prev_code << 8 | k;\r\n      // TODO(deanm): Figure out this clearing vs code growth logic better.  I\r\n      // have an feeling that it should just happen somewhere else, for now it\r\n      // is awkward between when we grow past the max and then hit a clear code.\r\n      // For now just check if we hit the max 12-bits (then a clear code should\r\n      // follow, also of course encoded in 12-bits).\r\n      if (next_code >= code_mask+1 && cur_code_size < 12) {\r\n        ++cur_code_size;\r\n        code_mask = code_mask << 1 | 1;\r\n      }\r\n    }\r\n\r\n    prev_code = code;\r\n  }\r\n\r\n  if (op !== output_length) {\r\n    console.log(\"Warning, gif stream shorter than expected.\");\r\n  }\r\n\r\n  return output;\r\n}\n\nvar index = {\r\n    GIFEncoder,\r\n    GIFDecoder: GifReader\r\n};\n\nexport default index;\n","import React, { useRef, useState, useEffect } from \"react\";\nimport minigif from \"./mini-gif.esm\";\nimport {\n  Container,\n  Paper,\n  Typography,\n  Toolbar,\n  AppBar,\n  Button,\n  ButtonGroup,\n  TextField,\n  Slider,\n  Grid,\n} from \"@material-ui/core\";\nimport { makeStyles } from \"@material-ui/core/styles\";\n\nconst useStyles = makeStyles((theme) => {\n  console.log(theme);\n\n  return {\n    mt10: {\n      marginTop: theme.spacing(2),\n    },\n    tipline: {\n      textAlign: \"left\",\n    },\n    tipLabel: {\n      color: theme.palette.secondary.main,\n      paddingRight: theme.spacing(2),\n    },\n  };\n});\n\nconst useGif = (file) => {\n  const [gifInfo, setGifInfo] = useState();\n  const [gifFrames, setGifFrames] = useState([]);\n\n  const decode = async (file) => {\n    const arrBuf = await file.arrayBuffer();\n    const buf = new Uint8Array(arrBuf);\n    const decodeGif = new minigif.GIFDecoder(buf);\n\n    const numFrames = decodeGif.numFrames();\n    const loopCount = decodeGif.loopCount();\n\n    const gifInfo = {\n      numFrames,\n      loopCount,\n      width: decodeGif.width,\n      height: decodeGif.height,\n    };\n\n    setGifInfo(gifInfo);\n\n    const frames = [];\n    for (let i = 0; i < numFrames; i++) {\n      const frameInfo = decodeGif.frameInfo(i);\n      const data = new Uint8ClampedArray(\n        4 * decodeGif.width * decodeGif.height\n      );\n      const imagedata = new ImageData(data, decodeGif.width, decodeGif.height);\n      if (i > 0 && frameInfo.disposal < 2) {\n        imagedata.data.set(new Uint8ClampedArray(frames[i - 1].data.data));\n      }\n      decodeGif.decodeAndBlitFrameRGBA(i, imagedata.data);\n      frames.push({ data: imagedata, delay: frameInfo.delay * 10 });\n    }\n    setGifFrames(frames);\n  };\n\n  useEffect(() => {\n    if (file) {\n      decode(file);\n    }\n  }, [file]);\n\n  return { gifInfo, gifFrames };\n};\n\nfunction App() {\n  const [file, setFile] = useState();\n  const [playStatus, setPlayStatus] = useState(\"PAUSED\");\n  const [nowFrame, setNowFrame] = useState(0);\n  const [jumpFrame, setJumpFrame] = useState(0);\n  const [downloadUrl, setDownloadUrl] = useState(\"\");\n  const [changedFrames, setChangedFrames] = useState([]);\n  const [inputConfig,setInputConfig] = useState({});\n  const { gifInfo, gifFrames } = useGif(file);\n  const playCanvasRef = useRef();\n  const styles = useStyles();\n\n  const handleInput = (key)=>(e)=>{\n    const value = e.target.value;\n    setInputConfig({...inputConfig,[key]:value});\n  };\n\n  const handleClick = (type) => () => {\n    if (type === \"ADDTEXT\") {\n      handleEdit();\n    } else if (type === \"RESET\") {\n      setChangedFrames([]);\n    } else if (type === \"DOWNLOAD\") {\n      if (changedFrames.length === 0) {\n        alert(\"没有改动\");\n        return;\n      }\n      generateGif();\n    }\n  };\n\n  const handleEdit = ()=>{\n    const { x,y,text,startFrame,endFrame } = inputConfig;\n    if(!x || !y || !text || !startFrame || !endFrame){\n      alert('检查输入!')\n      return ;\n    }\n    if(playStatus === 'PLAY')setPlayStatus('PAUSE');\n    \n    const canvas = playCanvasRef.current;\n    const ctx = canvas.getContext(\"2d\");\n    ctx.font = \"20px serif\";\n    const resArr = [];\n    for(let i = startFrame; i<=endFrame; i++){\n      const frame = gifFrames[i];\n      const w = frame.data.width;\n      const h = frame.data.height;\n      const delay = frame.delay;\n      ctx.putImageData(frame.data, 0, 0);\n      ctx.fillStyle = \"white\";\n      ctx.fillText(text, x, y);\n      const data = ctx.getImageData(0, 0, w, h);\n      resArr[i] = {data,delay}\n    };\n\n    \n    const frames = {...changedFrames,...resArr,length:gifInfo.numFrames};\n    console.log(frames);\n    setChangedFrames(frames);\n  };\n\n  const handleChangeStatus = (type)=>()=>{\n    if(type === 'PLAY' && playStatus !== 'PLAY'){      \n      setPlayStatus(type);\n      startLoop(true);\n    }else if(type === 'PAUSE' && playStatus !== 'PAUSE'){\n      setPlayStatus(type);\n    }\n  };\n\n  const handleFile = (e) => {\n    const file = e.target.files[0];\n    setFile(file);\n  };\n\n  const generateGif = () => {\n    const encoder = new minigif.GIFEncoder();\n    const canvas = playCanvasRef.current;\n    encoder.setRepeat(0); // loop forever\n    encoder.setDelay(100); // go to next frame every 100 ms\n\n    encoder.start(); // write header\n    encoder.setSize(gifInfo.width, gifInfo.height);\n    // console.log(gifFrames[nowFrame].data.data);\n    // encoder.addFrame(gifFrames[nowFrame].data.data,true);  // Render the frame from the canvas context.\n    // ctx.font = '20px serif';\n    // ctx.fillText('来追我啊！', 10, 50);\n    // encoder.addFrame(ctx);  // Render the frame from the canvas context.\n    for (let index = 0; index < gifFrames.length; index++) {\n      const frame = changedFrames[index] || gifFrames[index];\n      console.log(frame);\n      encoder.addFrame(frame.data.data, true);\n      encoder.setDelay(frame.delay);\n    }\n    encoder.finish(); // finish\n    const arr = encoder.stream().getUnit8Array();\n    const file = new Blob([arr]);\n    console.log(file);\n    const url = URL.createObjectURL(file);\n    setDownloadUrl(url);\n  };\n\n  const startLoop = () => {\n    setTimeout(loop,gifFrames[nowFrame].delay);\n  };\n\n  const loop = () => {\n    let next;\n    if (nowFrame + 1 >= gifInfo.numFrames) {\n      next = 0;\n    } else {\n      next = nowFrame + 1;\n    }\n    setNowFrame(next);\n  };\n\n  const drawFrame = ()=>{\n    const canvas = playCanvasRef.current;\n    const ctx = canvas.getContext(\"2d\");\n    const frame = changedFrames[nowFrame] || gifFrames[nowFrame];\n    ctx.putImageData(frame.data, 0, 0);\n  }\n\n  const handleSliderChange = (e, num) => {\n    if (playStatus === \"PLAY\") return;\n    if (num === jumpFrame) return;\n    setJumpFrame(num);\n  };\n\n  useEffect(() => {\n    if (playStatus === \"PAUSE\") {\n      setNowFrame(jumpFrame);\n    }\n  }, [jumpFrame]);\n\n  useEffect(()=>{\n    if(!playCanvasRef.current || !gifInfo)return;\n    const canvas = playCanvasRef.current;\n    canvas.width = gifInfo.width;\n    canvas.height = gifInfo.height;\n  },[gifInfo]);\n\n  useEffect(() => {\n    if (playCanvasRef.current && gifFrames.length) {\n      drawFrame();\n      if (playStatus === \"PAUSE\") { return;}\n      startLoop();\n    }\n  }, [gifInfo, gifFrames, nowFrame]);\n\n  return (\n    <div className=\"App\">\n      <AppBar position=\"static\">\n        <Toolbar>\n          <Typography variant=\"h6\">表情包DEMO</Typography>\n        </Toolbar>\n      </AppBar>\n      <Container maxWidth=\"sm\">\n        <Paper className={styles.mt10} variant=\"outlined\" square>\n          <canvas ref={playCanvasRef} />\n        </Paper>\n        <Slider\n          max={gifInfo?.numFrames ? gifInfo?.numFrames - 1 : 0}\n          value={jumpFrame}\n          valueLabelDisplay=\"auto\"\n          getAriaValueText={v=>v}\n          onChange={handleSliderChange}\n          aria-labelledby=\"continuous-slider\"\n        />\n\n        {gifInfo && (\n          <div className={styles.tipline}>\n            <Typography component=\"span\">Width:</Typography>\n            <Typography component=\"span\" className={styles.tipLabel}>\n              {gifInfo.width}\n            </Typography>\n            <Typography component=\"span\">Height:</Typography>\n            <Typography component=\"span\" className={styles.tipLabel}>\n              {gifInfo.height}\n            </Typography>\n            <Typography component=\"span\">总帧数:</Typography>\n            <Typography component=\"span\" className={styles.tipLabel}>\n              {gifInfo.numFrames}\n            </Typography>\n          </div>\n        )}\n\n        <Grid container spacing={2}>\n          <Grid item xs={12}>\n            {!gifInfo && (\n              <Button variant=\"contained\" color=\"primary\" disableElevation>\n                选择GIF文件\n                <TextField\n                  style={{ width: \"100%\", opacity: 0, position: \"absolute\" }}\n                  label=\"请选择GIF文件\"\n                  placeholder=\"请选择gif文件\"\n                  type=\"file\"\n                  onChange={handleFile}\n                />\n              </Button>\n            )}\n          </Grid>\n          <Grid item xs={3}>\n            <TextField\n              label=\"起始帧\"\n              type=\"number\"\n              onChange={handleInput('startFrame')}\n              InputLabelProps={{\n                shrink: true,\n              }}\n            />\n          </Grid>\n          <Grid item xs={3}>\n            <TextField\n              label=\"结束帧\"\n              type=\"number\"\n              onChange={handleInput('endFrame')}\n              InputLabelProps={{\n                shrink: true,\n              }}\n            />\n          </Grid>\n          <Grid item xs={3}>\n            <TextField\n              label=\"X坐标\"\n              type=\"number\"\n              onChange={handleInput('x')}\n              InputLabelProps={{\n                shrink: true,\n              }}\n            />\n          </Grid>\n          <Grid item xs={3}>\n            <TextField\n              label=\"Y坐标\"\n              onChange={handleInput('y')}\n              type=\"number\"\n              InputLabelProps={{\n                shrink: true,\n              }}\n            />\n          </Grid>\n          <Grid item xs={12}>\n            <TextField\n              style={{ width: \"100%\" }}\n              onChange={handleInput('text')}\n              label=\"添加的文字\"\n              type=\"text\"\n              InputLabelProps={{\n                shrink: true,\n              }}\n            />\n          </Grid>\n        </Grid>\n\n        <ButtonGroup\n          className={styles.mt10}\n          color=\"primary\"\n          disableElevation\n          variant=\"contained\"\n          aria-label=\"contained  primary button group\"\n        >\n          <Button onClick={handleChangeStatus(\"PLAY\")}>播放</Button>\n          <Button onClick={handleChangeStatus(\"PAUSE\")}>暂停</Button>\n          <Button onClick={handleClick(\"ADDTEXT\")}>确认编辑</Button>\n          <Button onClick={handleClick(\"RESET\")}>清除编辑</Button>\n        </ButtonGroup>\n        <Paper className={styles.mt10} variant=\"outlined\" square>\n          {downloadUrl && <img src={downloadUrl} />}\n        </Paper>\n        <ButtonGroup\n          className={styles.mt10}\n          color=\"primary\"\n          disableElevation\n          variant=\"contained\"\n          aria-label=\"contained  primary button group\"\n        >\n          <Button onClick={handleClick(\"DOWNLOAD\")}>生成GIF</Button>\n          {downloadUrl&&<Button download=\"demo.gif\" href={downloadUrl}>下载生成的GIF</Button>}\n        </ButtonGroup>\n      </Container>\n    </div>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport CssBaseline from \"@material-ui/core/CssBaseline\";\nReactDOM.render(\n  <React.StrictMode>\n    <React.Fragment>\n      <CssBaseline />\n      <App />\n    </React.Fragment>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}